Qadence simplifies the execution of digital-analog
workloads on neutral atom quantum computers where the local
addressability is restricted.

In this regime, which we will refer to as *semi-local addressing*,
the full Hamiltonian of the qubit system realized with neutral
atoms comprises the following terms:

$$
\mathcal{H} = \mathcal{H}_{\textrm{global}} + \mathcal{H}_{\textrm{int}} + \mathcal{H}_{\textrm{local}}
$$

The first two terms are the standard components of a neutral atom Hamiltonians
and read as follows:

$$
    \mathcal{H}_{\textrm{global}} = \frac{\Omega}{2}\sum_{i}^N \left(
        \textrm{cos}(\phi)\sigma^x_i - \textrm{sin}(\phi)\sigma^y_i \right) -
        \delta \sum_{i}^N \hat{n}_i \\
    \mathcal{H}_{\textrm{int}} = \sum_{i<j} \frac{C_6}{|R_i - R_j|^6} \hat{n}_i \hat{n}_j
$$
where $\Omega$ is the Rabi frequency, $\phi$ the global phase, $\delta$ the
detuning which can all be time-dependent (here omitted for simplicity). The operator
$\hat{n}_i = \frac{1+\sigma_i^z}{2}$ is the occupation operator for the Rydberg state.
$R_i$ represents instead the spatial coordinates of the i-th qubit.

The local addressability term reads instead:

$$
    \mathcal{H}_{\textrm{local}}(w^{drv}, w^{det}) = \frac{\tilde{\Omega}}{2}\sum_{i}^N
        w_i^{drv}\left(\textrm{cos}(\phi)\sigma^x_i - \textrm{sin}(\phi)\sigma^y_i \right) -
        \Delta \sum_{i}^N w_i^{det} \hat{n}_i
$$

In this Hamiltonian, the local addressing pattern in both Rabi frequency and detuning
is determined by the weights $w^{drv} = \{w_i^{drv}\}$ and $w^{det} = \{w_i^{det}\}$ respectively. These
weights are assigned before starting the simulation and they should have a unit sum.
Their action is to effectively modulate the amplitude of the local drive/detuning pulses given by
$\tilde{\Omega}$ and $\Delta$ which are here considered time-independent for simplicity.

Qadence implements the Hamiltonian above in two different flavors of increasing complexity described
below.

## Circuit constructor

The `rydberg_hea` constructor routine allows to
build a circuit instance implementing a basic version of the Hamiltonian
evolution described above where both $\Delta$ and $\tilde{\Omega}$ coefficients
are considered constants. Furthemore, **no global drive and detuning** are explicitly added
to the Hamiltonian. Therefore, the final Hamiltonian generator of the circuit reads as follows:

$$
\matchcal{H} = \mathcal{H}_{\textrm{local}}(w^{drv}, w^{det}) + \mathcal{H}_{\textrm{int}}
$$

This implementation does not perform any checks on the weights normalization, thus
making it not realistic. This implies that global drive and detuning can be retrieved
by appropriately choosing the weights.

You can easily create a Rydberg hardware efficient ansatz implementing multiple layers
of the evolution generated by the local addressing Hamiltonian:

$$
\mathcal{H}_{evo} = \sum_j \mathcal{H}_{\textrm{local}}(w_{j}^{drv}, w_{j}^{det})
$$

Notice that in real-device implementation, one layer only is usually possible.

```python exec="on" source="material-block" result="json" session="rydb-hea"
import qadence as qd
from qadence import rydberg_hea, rydberg_hea_layer

n_qubits = 4
n_layers = 2
register = qd.Register.line(n_qubits)

# ansatz constructor
# the evolution time is parametrized for each layer of the evolution
ansatz = rydberg_hea(
    register,
    n_layers=n_layers,  # number of subsequent layers of Hamiltonian evolution
    addressable_detuning=True,  # make the local detuning weights w_i^{det} as variational parameters
    addressable_drive=True, # make the local drive weights w_i^{drv} as variational parameters
    tunable_phase=True, # make the phase \phi as a variational parameter
)

# alternatively, a single ansatz layer can also be created for
# better flexibility

# these can be variational parameters
tevo_drive = 1.0  # evolution time for the locally addressed drive term
tevo_det = 1.0 # evolution time for the locally addressed detuning term
tevo_int = 1.0  # evolution time for the interaction term

# these can be list of variational parameters
weights_drive = [0.0, 0.25, 0.5, 0.25]
weights_det = [0.0, 0.0, 0.5, 0.5]

ansatz_layer = rydberg_hea_layer(
    register,
    tevo_det,
    tevo_drive,
    tevo_int,
    detunings=weights_det,
    drives=weights_drive,
)
```

This circuit constructor is meant to be used with fully differentiable backends such as
PyQTorch and mainly for quick experimentation with neutral atom compatible ansatze.

## Usage with digital-analog emulation

A full integration with the [emulated digital-analog framework](./analog-basics.md) for realistic
simulations is *coming soon*.
