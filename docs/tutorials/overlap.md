`qadence` offers some convenience functions for computing the overlap between the
wavefunctions generated by two quantum circuits. We define the overlap between
the wavefunction generated by the circuits $U$ and $W$ as:

$$
S = |\langle \psi_U | \psi_W \rangle|^2 \;\; \textrm{where} \; \psi_U = U|\psi_0\rangle
$$

Let's jump right in and see how to compute the overlap between two very simple parametric circuits
consisting of a single `RX` rotation on different qubits. We expect the overlap to be
non-zero only when the rotation angle is different from $\pi$ for both rotations:

```python exec="on" source="material-block" result="json" session="overlap"
import torch
import numpy as np
from qadence import Overlap, OverlapMethod, QuantumCircuit, H, RX, X, FeatureParameter, hea


# let's create two quantum circuits
# with a single qubit rotation on two random qubits
n_qubits = 4
qubits = np.random.choice(list(range(n_qubits)), n_qubits, replace=True)

phi = FeatureParameter("phi")
circuit_bra = QuantumCircuit(n_qubits, RX(qubits[0], phi))

psi = FeatureParameter("psi")
circuit_ket = QuantumCircuit(n_qubits, RX(qubits[1], psi))

# values for the feature parameters
values_bra = {"phi": torch.Tensor([torch.pi / 2, torch.pi])}
values_ket = {"psi": torch.Tensor([torch.pi / 2, torch.pi])}

# calculate overlap by assigning values to the given bra and ket circuits
ovrlp = Overlap(circuit_bra, circuit_ket)
ovrlp = ovrlp(bra_param_values=values_bra, ket_param_values=values_ket)

print("Overlap with exact method:\n", ovrlp)
```

The `Overlap` class above inherits from `QuantumModel` and its forward method
computes the overlap given input parameter values. By default,
the overlap is computed exactly by performing the dot product of the wavefunction propagated
from the bra and ket circuits.

However, one can use the `OverlapMethod` enumeration
to choose which kind of overlap to compute via the `overlap_method` argument of the
overlap constructor class. Currently, one can choose from:

* `EXACT`: exact computation using the wavefunction matrix representation. Does not work with
on real devices since it assumes access to the full qubit system wavefunction.
* `COMPUTE_UNCOMPUTE`: exact or sampling-based computation using brak $U$ and ket $W^{\dagger}$ unitaries.
* `SWAP_TEST`: exact or sampling-based computation using the SWAP test method.
* `HADAMARD_TEST`: exact or sampling-based computation using the Hadamard test method.
* `JENSEN_SHANNON`: compute the overlap using the Jensen-Shannon divergence of the two
probability distributions obtained by sampling the propagated circuits. This will yield a different
result than the other methods.

All methods (except for the `EXACT` method) take an optional `n_shots` argument which can be used
for performing shot-based calculations.

!!! warning
    If you select a finite number of shots, the overlap is not differentiable. Therefore,
    it cannot be used as output of a quantum model if gradients are required.

```python exec="on" source="material-block" result="json" session="overlap"
# calculate overlap with SWAP test
ovrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)
ovrlp_ha = ovrlp(values_bra, values_ket)
print("Overlap with SWAP test:\n", ovrlp_ha)

# calculate overlap with SWAP test
# using a finite number of shots
ovrlp = Overlap(circuit_bra, circuit_ket, method=OverlapMethod.SWAP_TEST)
ovrlp_ha = ovrlp(values_bra, values_ket, n_shots=10_000)
print("Overlap with SWAP test with finite number of shots:\n", ovrlp_ha)
```
