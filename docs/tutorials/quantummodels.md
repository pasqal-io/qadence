Quantum programs are executed via [`QuantumModel`][qadence.models.quantum_model.QuantumModel]s.
They serve three purposes:

_**Execution**_: They define on which backend your program is using (i.e. which simulator or
which device), they compile your circuit to the native backend representation.

_**Parameter handling**_: They conveniently handle the two types of parameters that qadence supports
(*feature* and *variational* parameters) and make sure they are embedded correctly in the given
backend. Details on parameters can be found in [this section](parameters.md).

_**Differentiability**_: They make your program differentiable by defining what we call a
*differentiable backend*.  There are currently two differentiable backends: the autodiff backend
which works with PyTorch-based simulators, and the parameter shift rule (PSR) based backend which
can make any program differentiable (even on hardware).

!!! note "Backends"
    Quantum models can execute on a number of different backends like simulators, or real hardware.
    Commonly used backends are: The [*PyQTorch*](https://github.com/pasqal-io/PyQ) backend which
    implements a state vector simulator, or the [*Pulser*](https://pulser.readthedocs.io/en/stable/)
    backend (pulse sequences on programmable neutral atom arrays).  For more information see
    [backend tutorial](backends.md).

The base `QuantumModel` exposes the following methods:

* `QuantumModel.run()`: To extract the wavefunction after propagating the quantum
  circuit. This works only for certain backends
* `QuantumModel.sample()`: Sample bitstring out of the quantum state generated by
  the input circuit. This is available for all backends.
* `QuantumModel.expectaction()`: Compute the expectation value of an observable

Every `QuantumModel` is an instance of a
[`torch.nn.Module`](https://pytorch.org/docs/stable/generated/torch.nn.Module.html) which means that
its `expectation` method is _**differentiable**_.

Upon construction of the model a compiled version of the abstract `QuantumCircuit` is
created:
```python exec="on" source="material-block" result="json" session="quantum-model"
from qadence import QuantumCircuit, QuantumModel, RX, Z, chain

# construct abstract circuit
# at this point we cannot run anything yet!
n_qubits = 2
block = chain(RX(0, "x"), RX(1, "x"))
circuit = QuantumCircuit(n_qubits, block)
observable = Z(0)


# now we construct a QuantumModel which will compile
# the abstract circuit to the backend we specify
model = QuantumModel(circuit, observable, backend="pyqtorch", diff_mode='ad')

# the converted circuit is a private attribute and should not
# manually be tampered with, but we can at least verify its there
print(model._circuit.native)

from pyqtorch.modules import QuantumCircuit as PyQCircuit
assert isinstance(model._circuit.native, PyQCircuit)
```

Now we can compute the wavefunction, sample, or compute the expectation:
```python exec="on" source="material-block" result="json" session="quantum-model"
import torch

values = {"x": torch.rand(3)}

wf = model.run(values)
print(f"{wf=}")

xs = model.sample(values, n_shots=100)
print(f"{xs=}")

ex = model.expectation(values)
print(f"{ex=}")
```

You can also measure multiple observables by passing a list of blocks.
```python exec="on" source="material-block" result="json" session="quantum-model"
model = QuantumModel(circuit, [Z(0), Z(1)], backend="pyqtorch", diff_mode='ad')
ex = model.expectation(values)
print(ex)
```

### Quantum Neural Network (QNN)

The `QNN` is a subclass of the `QuantumModel` geared towards quantum machine learning. See the [ML
Tools](/tutorials/ml_tools.md) section or the [`QNN`][qadence.models.QNN] for more detailed
information.

!!! note "Parametrized Models"
    For more information on parametrizing `QuantumModel`s refer to the [parametric program
    tutorial](/tutorials/parameters.md#parametrized-models).
